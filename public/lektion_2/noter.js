export const noter = [
    { titel: "Data Variable Declaration", billede: "lektion_2/images/scope.png", deklerationer: [
        { dek: "const", beskrivelse: `Vi anvender 'const' som standard, medmindre vi har behov for at reassigne variabler. Her er det essentielt at forstå at det er referrencen der er konstant og ikke selve værdien.` }, 
        { dek: "let", beskrivelse: `Vi anvende 'var' når vi løber ind i problemer med const. Altså, at der er et behov for ar reassigne variablen. Her er det essentielt at forstå, at 'let' har 'block scope', hvilket betyder at deklerationen kun gælder indenfor curly brackets { }.`},
        { dek: "var", beskrivelse: `Vi vil generelt ikke anvende os af 'var' i JS, hvis vi kan anvende os af 'const' eller 'let'. Dette skyldes, at 'var' har function scope, men ikke 'block scope', hvilket kan føre til fejl. Variabler deklareret med 'var' lever altså enten i funktionen hvor den er dekleraret eller globalt, hvis det er udenfor selve funktionen. Dette kan føre til at vi overskiver variabler, som vi ikke vil overskrive.`} ],
        beskrivelse: `Såvel som det er vigtigt at kende til datatyperne i JS, så er det ligeså vigtigt at kende til variabel deklerationer.` },
    { titel: "Functions", billede: "lektion_2/images/functions.png", deklerationer: [
        { dek: "Klassisk funktion", beskrivelse: "I den klassiske funktion syntax, så bliver vi nødt til at deklarere med 'function' keywordet. Den klassiske funktion kan kaldes, før den er deklareret i koden (hoisting). Herudover kan man anvende dem i callback funktioner, hvilket du finder mere om i 'Callback Functions' afsnittet nedenfor." },
        { dek: "Anonym funktion", beskrivelse: "Anonyme funktioner kan vi også referere til som 'function expressions'. Vi deklarerer derfor funktionen som en variabel, eventuelt med const. I modstæning til klassiske funktioner, så kan anonyme funktioner ikke hoistes. Vi skal altså kalde dem efter deklarationen." },
        { dek: "Arrow funktion", beskrivelse: "Arrow funktioner har først og fremmest en kortere syntax. Hvor klassiske og anonyme funktioner har deres eget 'this', så arver arrow funktioner fra det omgivende scope. I og med at de har en kortere syntax, så er det også mere anvendte til loop metoder som .map, .filter, .forEach etc." }], 
        beskrivelse: "For at deklarere de mere klassiske funktioner i JS, så skal vi anvende os af 'function' keywordet. Derudover skal funktionen indeholde paramtetre og afslutningsvist selve JS statementet, som skal være indenfor curly brackets { }. Hvor vi i Java skal specificere datatypen som retuværdi i en metode (statisk typet), så er dette ikke nødvendigt i JS funktioner (dynamisk typet)." },
    { titel: "Callback Functions", billede: "lektion_2/images/callback.png", beskrivelse: "Callback funktioner kaldes i JS også for 'first class functions'. En callback funktion bliver sendt videre til en anden funktion som argument, og bliver POTENTIALLY INVOKED. Grunden til at der er lagt ekstra vægt på 'potentially', er at det er ikke altid sikkert at funktionen kaldes. Det kan eksempelvis være at man har noget forretningslogik, der gør at funktionen kun kaldes, hvis en betingelse er opfyldt. Det kan også ske at man har en Event Listener, der kun kun kaldes hvis et event indtræffer, såsom at en bruger klikker på en specifik knap. " },
    { titel: "NPM & Package Managers", beskrivelse: "NPM står for 'Node Package Manager' og er ansvarlig for moduler og packages i Node.JS. NPM et et build tool, ligesom vi kender til Maven, når vi har arbejdet med Spring Boot og Java. Det kan ses som et værktøj der hjælper os med at interagerer med programmerings 'environment'. Der findes ligeså andre package managers, såsom Gradle, Gem og Rake. Hvor vi i Maven har en pom.xml fil til at håndtere dependencies og metadata, så har vi med NPM en package.json fil." },
    { titel: "package.json & Set Up Tutorial", billede: "lektion_2/images/package_json1.png",  deklerationer: [
        { dek: "npm init", beskrivelse: "Vi kan oprette et projekt ved at bruge ovenstående kommando i terminalen. Efterfølgende vil vi blive bedt om at udfylde en række spørgsmål, så vi kan initialisere projektet og derefter vil der automatisk oprettes en package.json fil. Der vil samtidig oprettes en 'package-lock.json, der fortæller os præcis hvilke pakker der er installeret. Dette afhjælper problematikken: 'Works on my machine, not on yours'." }], 
        beskrivelse: "package.json indeholder dependencies og metadata for et projekt. Vi arbejder eksempelvis med webframeworket Express, hvilket vi specificerer i denne fil. I package.json kan vi også opsætte scripts til b.la. udviklings- og produktionsmiljøer. Det er også i package.json at vi kan specificerer om vi arbejder med ES moduler gennem (type: 'module'). Nendenfor er en tutorial til hvordan man ved hjælp af npm init kan oprette en package.json fil." },
    { titel: "Express Server", beskrivelse: "Vi kan oprette en express server på to måder. Enten gennem common.js, hvor vi gør brug af require() og module.exports eller vha. ES moduler, hvor vi anvender import og export. Dette kræver at vi har type: module i vores package.json, som specificeret ovenfor." },
    { titel: "Send data with Get Requests over HTTP", },
    { titel: "Node Modules ", }
];