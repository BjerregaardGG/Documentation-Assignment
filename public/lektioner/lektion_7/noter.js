export const noter = [
    { titel: "How code placement affects app memory and effeciency", billede: "", deklerationer: [
        { dek: "Placering af funktioner", billede: "lektioner/lektion_7/images/templateEngine.png", beskrivelse: "TemplateEngine filen indeholder to konstane variabler 'header' og 'footer' som bliver initialiseret med readPage() funktionen, som læses en gang ved serverstart. Det vil sige at de konstant er i memory, imens at serveren kører, hvilket man skal være opmærksom på ved meget store filer, men da det er HTML, har det ikke kritisk memory betydning. Havde man læst 'header' og 'footer' inde i funktionen 'constructPage(), så vil filerne blive læst hver gang funktionen kaldes, hvilket kan belaste CPU. Derudover så er 'constructPage()' funktionen også global. Havde vi valgt at definere funktionen inde i en 'route handler' i app.js, så ville vi oprette en ny funktion, hver gang et endpoint bliver kaldt, hvilket også vil kræve mere memory." },
        { dek: "SSR og dets påvirkning på CPU", billede: "lektioner/lektion_7/images/appjs.png", beskrivelse: "Når vi anvender os af SSR, så sender vi HTML fra vores server, fremfor at vi bygger siden i klienten. Dette medfører at serveren bruger mere CPU-belastning på at bygge HTML'en. Anvender vi derimod CSR, så vil serveren have en mindre CPU-belastning, da det er klienten der genererer HTML'en. Når vi flytter ansvarsområdet til klienten, så vil det til gengæld så kræve mere browser CPU og memory, da den står for at skabe DOM'en."}], 
        beskrivelse: "Nedenstående SSR kode, er eksempler på hvordan kode og dets placering påvirker memory og belastning af softwaren. Hvordan vi placerer koden i forhold til om det er globalt eller i vores routes, samt om det det kører på server-niveau (SSR) eller klient-niveau (CSR), har betydning for memory og CPU belastning." },
    { titel: "Structuring code", billede: "", deklerationer: [
        { dek: "🚩 structuring of code", billede: "lektioner/lektion_7/images/badcode.png", beskrivelse: "" },
        { dek: "💚 structing of code", billede: "lektioner/lektion_7/images/goodcode.png", beskrivelse: ""}
    ], beskrivelse: "I ovenstående eksempel har vi splittet vores kode op i genanvendelige moduler. templateEngine.js står for at læse og bygge HTML'en. pagesUtil.js kalder funktionerne i templateEngine.js, men vi opbevarer kun de færdige HTML sider her. Alt dette kunne godt placeres i app.js, men vi ønsker ikke at blande funktionalitet og ansvarsområder (single responsibility). Vi ønsker at genbruge funktioner, hvilket vi gør gennem at ES 'export & import', så vi undgår at dublere kode. Samtidig, så vil filer der bliver for lange, være både sværere at læse og navigere i, samtidig med at det bliver mere kritisk at debugge og ændre, da koden er tæt koblet." },
    { titel: "Server-side vs Client-side rendering", billede: "", deklerationer: [
        { dek: "Load time", beskrivelse: "🟢 SSR har en hurtigere load time, da vi sender den færdige HTML til klienten.", beskrivelse2: "🔴 CSR har en langsommere load time, da klienten selv skal til at opbygge DOM'en inden siden vises." },
        { dek: "Ressources", beskrivelse: "🟠 SSR bruger mere CPU på server-niveau (uddybet ovenfor), da HTML genereres for hver serverkald.", beskrivelse2: "🟠 CSR har mindre CPU og memory belastning på server-niveau, men derimod højere belastning for klienten, da det er browseren der håndterer HTML'en." },
        { dek: "SEO", beskrivelse: "🟢 SSR er mere optimalt for SEO, da søgemaskiner får den fulde HTML side og derved kan læse siden direkte.", beskrivelse2: "🔴 CSR er mindre SEO-venlig, da indholdet genereres dynamisk og ikke alle søgemaskiner venter på at indholdet læses færdigt. Kan især være negativt, hvis man har meget indhold, der skal genereres i ens klient." },
        { dek: "CORS", beskrivelse: "🟢 SSR har ikke CORS problematikker, da alt er fra samme 'origin'", beskrivelse2: "🔴 CSR kræver oftest CORS configuration, hvilket kan give problemer, hvis vi ikke har konfiguration af headers."}],
        beskrivelse: "" },
    ]