export const noter = [
    { titel: "How code placement affects app memory and effeciency", billede: "", deklerationer: [
        { dek: "Placering af funktioner", billede: "lektioner/lektion_7/images/templateEngine.png", beskrivelse: "TemplateEngine filen indeholder to konstane variabler 'header' og 'footer' som bliver initialiseret med readPage() funktionen, som l칝ses en gang ved serverstart. Det vil sige at de konstant er i memory, imens at serveren k칮rer, hvilket man skal v칝re opm칝rksom p친 ved meget store filer, men da det er HTML, har det ikke kritisk memory betydning. Havde man l칝st 'header' og 'footer' inde i funktionen 'constructPage(), s친 vil filerne blive l칝st hver gang funktionen kaldes, hvilket kan belaste CPU. Derudover s친 er 'constructPage()' funktionen ogs친 global. Havde vi valgt at definere funktionen inde i en 'route handler' i app.js, s친 ville vi oprette en ny funktion, hver gang et endpoint bliver kaldt, hvilket ogs친 vil kr칝ve mere memory." },
        { dek: "SSR og dets p친virkning p친 CPU", billede: "lektioner/lektion_7/images/appjs.png", beskrivelse: "N친r vi anvender os af SSR, s친 sender vi HTML fra vores server, fremfor at vi bygger siden i klienten. Dette medf칮rer at serveren bruger mere CPU-belastning p친 at bygge HTML'en. Anvender vi derimod CSR, s친 vil serveren have en mindre CPU-belastning, da det er klienten der genererer HTML'en. N친r vi flytter ansvarsomr친det til klienten, s친 vil det til geng칝ld s친 kr칝ve mere browser CPU og memory, da den st친r for at skabe DOM'en."}], 
        beskrivelse: "Nedenst친ende SSR kode, er eksempler p친 hvordan kode og dets placering p친virker memory og belastning af softwaren. Hvordan vi placerer koden i forhold til om det er globalt eller i vores routes, samt om det det k칮rer p친 server-niveau (SSR) eller klient-niveau (CSR), har betydning for memory og CPU belastning." },
    { titel: "Structuring code", billede: "", deklerationer: [
        { dek: "游뛀 structuring of code", billede: "lektioner/lektion_7/images/badcode.png", beskrivelse: "" },
        { dek: "游눜 structing of code", billede: "lektioner/lektion_7/images/goodcode.png", beskrivelse: ""}
    ], beskrivelse: "I ovenst친ende eksempel har vi splittet vores kode op i genanvendelige moduler. templateEngine.js st친r for at l칝se og bygge HTML'en. pagesUtil.js kalder funktionerne i templateEngine.js, men vi opbevarer kun de f칝rdige HTML sider her. Alt dette kunne godt placeres i app.js, men vi 칮nsker ikke at blande funktionalitet og ansvarsomr친der (single responsibility). Vi 칮nsker at genbruge funktioner, hvilket vi g칮r gennem at ES 'export & import', s친 vi undg친r at dublere kode. Samtidig, s친 vil filer der bliver for lange, v칝re b친de sv칝rere at l칝se og navigere i, samtidig med at det bliver mere kritisk at debugge og 칝ndre, da koden er t칝t koblet." },
    { titel: "Server-side vs Client-side rendering", billede: "", deklerationer: [
        { dek: "Load time", beskrivelse: "游릭 SSR har en hurtigere load time, da vi sender den f칝rdige HTML til klienten.", beskrivelse2: "游댮 CSR har en langsommere load time, da klienten selv skal til at opbygge DOM'en inden siden vises." },
        { dek: "Ressources", beskrivelse: "游 SSR bruger mere CPU p친 server-niveau (uddybet ovenfor), da HTML genereres for hver serverkald.", beskrivelse2: "游 CSR har mindre CPU og memory belastning p친 server-niveau, men derimod h칮jere belastning for klienten, da det er browseren der h친ndterer HTML'en." },
        { dek: "SEO", beskrivelse: "游릭 SSR er mere optimalt for SEO, da s칮gemaskiner f친r den fulde HTML side og derved kan l칝se siden direkte.", beskrivelse2: "游댮 CSR er mindre SEO-venlig, da indholdet genereres dynamisk og ikke alle s칮gemaskiner venter p친 at indholdet l칝ses f칝rdigt. Kan is칝r v칝re negativt, hvis man har meget indhold, der skal genereres i ens klient." },
        { dek: "CORS", beskrivelse: "游릭 SSR har ikke CORS problematikker, da alt er fra samme 'origin'", beskrivelse2: "游댮 CSR kr칝ver oftest CORS configuration, hvilket kan give problemer, hvis vi ikke har konfiguration af headers."}],
        beskrivelse: "" },
    ]