export const noter = [
    { titel: "Nodemon", billede: "lektion_3/images/nodemon.png", deklerationer: [
        { dek: "npm install -g nodemon", beskrivelse: `Installerer nodemon globalt på ens maskine, så man kan anvende 'nodemon' kommandoen på tværs af ens projekter. Kan kræve 'sudo', hvis man skal have admin rettigheder.` }, 
        { dek: "npm install nodemon", beskrivelse: `Installerer nodemon lokalt i ens projekt, hvorefter det automatisk tilføjes til package.json filen. `},
        { dek: "nodemon app.js", beskrivelse: `Starter serveren med nodemon og restarter når der foretages ændringer projektets filer.`} ],
        beskrivelse: `Nodemon er et command-line værktøj som kan anvendes til automatisk at restarte vores server, når vi foretager os ændringer. Dette er rart som udvikler, da vi ikke konstant skal ned i terminalen og manuelt restarte vores server. Nodemon reserverer vi dog til 'development' og ikke 'production', da vi i produktion ofte har serveren til at køre konstant og ikke vil have det til at restarte på ændringer. ` },
    { titel: "Loop methods", deklerationer: [
        { dek: "forEach()", billede: "lektion_3/images/forEach.png", beskrivelse: "Hvis vi skal itterere over elementer i et array, så tænker vi typisk på et klassisk for loop. JS har en array metode kaldet forEach(), hvor vi udfører en funktion for hvert element i arrayet. Vi ændrer ikke det originale array eller returnerer et nyt, når vi anvender forEach()." },
        { dek: "map()", billede: "lektion_3/images/map.png", beskrivelse: "map() returnerer i modsætning til forEach(), et helt nyt array. map() anvender vi, når vi gerne vil transformere hvert element i et array. Det nye array som map() returnerer, vil have samme længde som det originale array." },
        { dek: "filter()", billede: "lektion_3/images/filter.png", beskrivelse: "filter() går ind og filtrerer elementer i arrayet ud fra en eller flere betingelser. filter() returnerer også et nyt array, men længden er ikke nødvendigvis den samme, da der kan være elementer der ikke opfylder betingelsen." },
        { dek: "reduce()", billede: "lektion_3/images/reduce.png", beskrivelse: "Med reduce() så reducerer vi elementerne i vores array til en enkelt værdi. Denne værdi kan være af flere forskellige datatyper. reduce tager imode 4 parametre: (accumulator, element, index, array). Accumulator er det nuværende/løbende resultat og element er det element der behandles nu og her. Foruden dette, så kan reduce også have en 'initial value', som er et udtryk for startværdien. I nedenstående eksempel ved beregning af gennemsnit, så er accumulator summen, hvilket her er den løbende sum. Elementet er det element, vi hver under itterationen lægger til summen." },
        { dek: "find()", billede: "lektion_3/images/find.png", beskrivelse: "find() anvender vi til kun at finde det første element der opfylder en betingelse. Er vores betingelse ikke opfyldt, så vil find() returnere 'undefined'. Hvor filter() returnerer et array af matches, så vil find() altså kun returnere det første match element." },
        { dek: "indexOf()", billede: "lektion_3/images/indexOf.png", beskrivelse: "indexOf() anvender vi til at lede efter indexet for et specifikt element. indexOf() er rigtig relevant i situationer, hvor vi gerne vil tjekker hvorvidt noget er til stede eller ikke, eller hvor det er placeret. Det kan være at vi vil tjekke hvorvidt en person findes i en liste, eller sammenligne indholdet af to lister. Er et element ikke til stede, så vil indexOf() returnere -1." }], 
        beskrivelse: "" },
    { titel: "Method Chaining", billedeVis: "lektion_3/images/chaining.png", beskrivelse: "Vi kan kombinere flere loop methods, hvilket også skaber mere letlæselig, tydeligere og kortere kode."},
    { titel: "Functional approach to loops", deklerationer: [
        { dek: "1. Brevity", beskrivelse: "Funktionelle loop metoder, såsom forEach kræver mindre kode, end traditionelle for loops." },
        { dek: "2. Clarity", beskrivelse: "Loop metoder kommunikkerer internt. Når vi eksempelvis anvender os af filter, så er det forholdsvist tydeligt for os hvad koden gør. Vi forstår altså formålet." },
        { dek: "3. No accidental indexing errors (out of bounds)", beskrivelse: "Funktionelle metoder håndterer index internt og vi løber ikke ind i 'indexOutOfBounds' errors som vi eksempelvis ville kunne komme ud for ved det traditionelle for loop." },
        { dek: "4. Avoids for…of / for…in confusion", beskrivelse: "Ved den traditionelle tilgang skal vi huske på forskellen mellem for...of, der returnerer en liste over nøglerne på det objekt, der itereres over, mens for..of returnerer en liste over værdierne på det objekt, der itereres over. Dette undgår vi med loop methods." },
        { dek: "5. Able to access both element and index at the same time", beskrivelse: "Funktionelle metoder tager imod element og index i parameteren, hvilket betyder, at vi ikke manuelt skal holde styr på dem." },
        { dek: "6. Avoids side effects", beskrivelse: "Med funktionelle metoder ændrer vi ikke det originale array og undgår derved side effects, hvis vi senere eksempelvis ændrer på variabler." },
        { dek: "7. Shorter and more readable / maintainable", beskrivelse: "Funktionelle metoder er ofte lettere at forstå og bliver derved også lettere at ændre eller senere udvide." }],
        beskrivelse: "Fordelen ved at anvende de ovenstående loop metoder er at vi arbejder funktionelt, hvor vi ikke muterer det oprindelige array. forEach(), map(), filter() og reduce() ændrer ikke på det originale array, men returnerer derimod et nyt. Nedenfor er 8 argumenter, der argumenter for en funktionel tilgang til loops." },
    { titel: "URL Terminology", billedeVis: "lektion_3/images/url.png", beskrivelse: ""},
    { titel: "POST request with parse body", billede: "lektion_3/images/post.png", beskrivelse: "Førend at vi kan 'parse body' i en POST request, så kræver det at vi har: app.use(express.json()). Dette gør at vores express server kan læse JSON fra vores request body. req.body vil indeholde dataen som er sendt fra klienten i JSON. POST kan tage imode req.body, men kan også modtage data fra andre steder, såsom req.params (path variables) eller req.query (query strings)."},
];