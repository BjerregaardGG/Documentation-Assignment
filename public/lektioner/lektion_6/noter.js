export const noter = [
    { titel: "Running scripts with NPM", billede: "lektioner/lektion_6/images/scripts.png", deklerationer: [
        { dek: "Development script", beskrivelse: `Dette script er et eksempel på et development (udvkilings) script. Når vi specificerer 'cross-env PORT=8080', så sætter vi vores PORT miljøvariabel til at lytte på port 8080 og sørger samtidig for at det virker på tværs af forskellige 'environments', herunder Linux, macOS, Linux m.m. Samtidig så anvender vi os af nodemon, da vi er i et udviklingsmiljø, hvilket vil restarte serveren ved ændringer i filer.`}, 
        { dek: "Production script", beskrivelse: `Produktionsscriptet starter serveren med klassisk Node.js runtime. Her specificerer vi typisk ikke en port, da porten i produktion ofte sættes af serverens miljø.`},
        { dek: "nodemon.json", billede: "lektioner/lektion_6/images/nodemon_json.png", beskrivelse: "I vores development script specificerer vi at vi gerne vil køre serveren med nodemon, når vi skriver kommandoen: npm run dev. Vi kan i en nodemon.json fil så ydeligere specificere, for hvilke filer nodemon skal restarte serveren. "}],
        beskrivelse: "I vores package.json har vi muligheden for at definere custom scripts, der kører specifikke kommandoer. Her kan vi eksempelvis specificere scripts for udviklings- og produktionsmiljøer. Nedenstående scripts kan vi køre med: npm run (script key)." },
    { titel: "Defining Enviornment Variables natively", billede: "lektioner/lektion_6/images/env_variabler.png", beskrivelse: "Når vi definerer miljøvaribler, så er vi vant til at gøre det gennem en .env fil. Hvis vi skal sætte vores miljøvariabeler 'natively', så kan vi definere dem i vores terminal, inden vi starter serveren. Vi kan eksempelvis definere en miljøvariabel: 'PORT' og tilegne den værdien: '8080 i terminalen: PORT=8080 nodemon app.js. Dette vil sætte miljøvariablen og starte vores server. Efterfølgende kan vi i vores app.js indlæse denne variabel med process.env, som håndterer vores miljøvariabler." },
    { titel: "Fetching in client vs backend", billede: "", deklerationer: [
        { dek: "Client-side fetching", billede: "lektioner/lektion_6/images/client_fetching.png", beskrivelse: "Når vi fetcher i klienten, så sender vi et HTTP request direkte til det eksterne API, hvor dataen så vil gå direkte tilbage til browseren. Her skal vi dog være opmærksomme på at følsom data, såsom API nøgler, kan blive synlige for brugeren. Der findes også en hybrid af client side fetching, hvor vi anvender vores server som en mellemmand. Her fetcher vi fra vores klient til vores server, som så fetcher til et eksternt API." },
        { dek: "Backend-side fetching", billede: "lektioner/lektion_6/images/server_fetching.png", beskrivelse: "Når vi fetcher i vores backend, så er det vores server (app.js) der henter dataen fra et eksternt API. Når serveren så modtager svaret, så sender den dataen videre til klienten enten som JSON eller gennem Server-side-rendering (SSR), hvor vores server sender den færdige HTML. Her har vi mulighed for at ændre i dataen inden vi sender videre til vores klient. Vi kan undgå CORS configuration problemer, da browseren kun taler med vores egen server. Man kan dog samtidig argumentere for, at det er lidt langsommere, da der er et ekstra step i og med at vores server fungerer som mellemmand." }],
        beskrivelse: "" },
    { titel: "Semantic HTML", tags: ["<header>", "<article>", "<nav>", "<main>", "<section>", "<footer>"], 
        beskrivelse: "Når vi anvender os af semantisk HTML, så giver det først og fremmest mere læsbar kode, da vi opdeler vores HTML i afsnit, hvorunder vores indhold ligger. Anvender man kun '<div>', så kan strukturen hurtig blive meget rodet. Foruden dette, så optimerer det også SEO, da Google lettere kan forstå strukturen med semantiske tags. Det giver samtidig også bedre tilgængelighed for skærmlæsere og gør det lettere for os udviklere, at vedligeholde og ændre i koden. Nedenfor er eksempler på semantiske tags, så vi har anvendt i vores projekter. " },
    { titel: "Client files vs Server files", billede: "", deklerationer: [
        { dek: "Client files", billede: "", beskrivelse: "Klient filer er de filer som blandt andet ligger i vores public mappe. Dette kan være HTML, CSS, JS (script) og billeder. Alle de filer som vores browser indlæser og kører. De ligger som sagt ofte i en 'public' mappe, men kan også genereres af vores server." },
        { dek: "Server files", billede: "", beskrivelse: "Server files kører i vores backend. Det er blandt andet vores app.js fil, vores package.json eller util filer. Disse filer er ikke tilgængelige for browseren." }], 
        beskrivelse: "" },
    { titel: "How to style a footer", billede: "lektioner/lektion_6/images/footer.png", beskrivelse: "En sikker vinder, når det kommer til styling af footer vises i nedenstående eksempel. Her styler vi på vores body i forhold til 'viewport height', som vi sætter til minimum 95. Det betyder at vores body altid fylder mindst 95% af skærmens højde. Herudover anvender vi 'display: flex', så vores semantiske tags som '<header>', '<main>' og '<footer> bliver til flex items. Dette gør at vi kan anvende 'column' som flex-direction, så vores indhold placeres vertikalt, fremfor horisontalt. Afslutningsvist sætter vi main til 'flex: 1', hvilket gør at vores main fylder det rum vi har tilbage i vores body. " },
    { titel: "Structuring the frontend", billede: "", beskrivelse: "Når det kommer til at strukturere ens frontend, så er det langt hen af vejen en smagssag. Jeg kan personligt godt lide at opdele mine 'pages' i mapper, som hver især indeholder HTML siden og dens personlige script og images. Globable funktioner placerer jeg oftest i roden af public mappen, enten i en mappe for sig selv eller blot en util fil. Styling prøver jeg at lave så fleksibelt som muligt, hvilket også er derfor jeg oftest placerer det i en mappe for sig selv i public også. Jeg føler at dette giver en sammenhæng i og med, at alt der er relateret til en side er samlet et sted. Derudover så matcher strukturen også sitet, hvilket jeg synes gør det lettere at debugge. Hvis jeg eksempelvis vil slette en side, så ved jeg hvilken mappe jeg skal kigge i, fremfor at slette filer fordelt på mange forskellige mapper." },
    ]